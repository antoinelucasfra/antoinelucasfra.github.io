---
title: "Building Reproducible Analyses in Pharma with R"
description: "A practical guide to creating reproducible data analysis workflows in regulated pharmaceutical environments using R and Quarto."
author: "Antoine Lucas"
date: "2024-11-15"
categories: [R, Pharma, Reproducibility, Best Practices]
image: "featured.png"
draft: true
custom-callout:
  pharma-note:
    title: "Regulatory Note"
    color: "#17A89E"
    icon-symbol: "fa-flask"
  code-note:
    title: "Code Pattern"
    color: "#1a2a4a"
    icon-symbol: "fa-code"
---

## Introduction

In pharmaceutical data science, [reproducibility isn't just a best practice — it's a regulatory requirement]{.highlight bg-colour="gold" colour="navy"}. This post explores how to build reproducible analysis workflows using R, renv, and Quarto.

## Why Reproducibility Matters in Pharma

Regulatory agencies like the U.S. Food and Drug Administration (FDA) and the European Medicines Agency (EMA) require that analytical work be:

- **Documented** — Clear records of what was done
- **Traceable** — Ability to follow the analysis from raw data to conclusions
- **Reproducible** — The same inputs should produce the same outputs

::: {.callout-pharma-note}
Under 21 CFR Part 11 and comparable EMA guidance, "reproducible" means more than running the same script twice. It means you can demonstrate, on demand and years later, exactly which software version produced a specific result — including system libraries, not just R packages.
:::

## Key Tools for Reproducibility

### 1. Version Control with Git

```bash
git init # <1>
git add . # <2>
git commit -m "Initial analysis setup" # <3>
```
1. Initialise a Git repository in the project folder — creates the `.git/` directory that tracks all future changes.
2. Stage all current files — in a regulated context, this first commit typically includes the protocol, `renv.lock`, and the empty analysis skeleton.
3. Create the initial commit — the immutable starting point for the audit trail. Every subsequent change is traceable from here.

### 2. Dependency Management with renv

```{r}
#| eval: false
renv::init()        # <1>
renv::snapshot()    # <2>
renv::restore()     # <3>
```
1. Initialises renv for the project, creating `renv.lock` and the private library.
2. Captures the current state of all installed packages into `renv.lock`.
3. Installs the exact package versions recorded in `renv.lock` — use this on a new machine or after a `git pull`.

::: {.callout-code-note}
Always run `renv::snapshot()` **before** committing. The lockfile in your repository should reflect the state of the library you just tested, not the state from last week.
:::

### 3. Documenting with Quarto

Quarto ties the environment and the analysis together. Embed `sessionInfo()` or `renv::lockfile_read()` output directly in your reports so reviewers can see exactly what version of each package was used.

## Best Practices

1. **Use project-relative paths** — Never use absolute paths
2. **Document your environment** — Include session info in reports
3. **Validate data inputs** — Check data quality before analysis
4. **Version control everything** — Code, configuration, and documentation

## Conclusion

Building reproducible analyses requires upfront investment but [pays dividends in quality, compliance, and peace of mind]{.highlight bg-colour="teal" colour="snow"}.

## Session Info

```{r}
#| eval: false
sessionInfo()
```
